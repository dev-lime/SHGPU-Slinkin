<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	


</head>
<body>
<center>
<h1>ЛР2. Интерфейсы</h1>
</center>
<h2> Задание</h2>
<ol>
<li> (40)(40+5)(40+10)
Разработать два несвязанных иерархией класса односвязных списков TClassicList и TArrayList, 
релизующих интерфейс IList. Максимально возможное количество одних методов интерфейса
реализовывать через другие методы интерфейса.
<p>
TClassicList реализует классический список, со связкой узлов друг с другом с помощью указатетелей. 
</p><p>
TArrayList реализует список c храниением узлов в динамическом массиве.
</p><pre>IList=interface
    // добавляет узел в начало списка
    function addFirst(node:tobject):tobject;
    // добавляет узел в конец списка
    function addLast(node:tobject):tobject;
    // удаляет узел из начала списка
    function deleteFirst:tobject;
    // удаляет узел после переданного узла
    function deleteAfter(prevNode:tobject):tobject;
    // удаляет узел после переданного узла
    function insertAfter(prevNode:tobject):tobject;
    // Возращает 0 при равенстве содержимого узлов
    // Возращает 1, если содержимое node1 больше содержимого node2
    // Возращает -1, если содержимое node1 меньше содержимого node2
    function compare(node1,node2:tobject):integer;
    // Перемещает внутренний указатель в начало списка, возращает первый узел списка
    // Если список пуст, возращает nil 
    function first:tobject;
    // Перемещает внутренний указатель на следующий узел, возвращает данный узел
    // Если внутренний указатель вышел за пределы списка, возращает nil 
    function next:tobject;
    // Перемещает внутренний указатель на конец списка, возвращает последний узел списка
    // Если список пуст, возращает nil 
    function last:tobject;
    // Визуализирует узел
    procedure showNode(node:tobject);	
    // Создает и возвращает копию узла
    function copyNode(node:tobject):tobject;	
    // Уничтожает содержимое списка
    procedure destroyList;
end;
</pre>
Оба класса манипулируют узлами, порожденными от TObject, содержащими
одно значение встроенного типа данных (integer, real или string).
Узлы должны поддерживать отношения трихотомии и транзитивности (т.е. быть сортируемыми).
Допустимо разработать и использовать различные классы узлов.
Рекомендуется использовать узлы с подержкой разных встроенных типов. +5 баллов при использовании 
двух классов узлов со значениями различных встроенных типов. +10 баллов при использовании 
трех классов узлов со значениями различных встроенных типов.
<p>
Студент самостоятельно формирует классы TClassicList, TArrayList и класс(ы) узлов.
</p><p>
Разработать и проверить работоспособность следующих процедур:

</p></li><li>(10)
Простое слияние списков. LResult - целевой список, в конец которого <b>копируется</b> содержимое
списка L.
<pre>procedure ListMerge(LResult:IList; L:IList);
</pre>
<p>
Список L по окончании работы процедуры остается неизменным.

</p></li><li>(15)
Шахматное слияние списков. LResult - целевой список, в который через один 
узел <b>копируются</b> элементы списка L. Если списки различаются по длине, до
последние узлы списка будут копией окончания более длинного списка. 
<pre>procedure ListChessMerge(LResult:IList; L:IList);
</pre>
<p>
Список L по окончании работы процедуры остается неизменным.

</p></li><li>(15+20)
Сортировка списка. LResult - целевой список, в который будет <b>перемещено</b>
содержимое списка L, с упорядочиванием. Если список LResult изначально не пустой, перенести его содержимое в список L.
 Использовать сортировку вставками.
Если ASC=true, использовать сортировку по возрастанию, иначе - по невозрастанию.
<pre>procedure ListSort(LResult:IList; L:IList; ASC:boolean);
</pre>
<p>
По окончании сортировки список L должен быть пустым.

</p></li></ol>


</body></html>